import {
  Entity,
  EntityOptions,
  MoveOptions,
  PathfindingEntityController,
  PathfindingOptions,
  Quaternion,
  QuaternionLike,
  RigidBodyType,
  SceneUI,
  Vector3Like,
  World,
} from 'hytopia';

import { SkillId } from '../config';
import type BaseItem from '../items/BaseItem';
import GamePlayerEntity from '../GamePlayerEntity';
import type IInteractable from '../interfaces/IInteractable';
import type IDamageable from '../interfaces/IDamageable';

export type BaseEntityDialogue = {
  _id?: number; // internal autogenerated id
  text: string;
  options?: BaseEntityDialogueOption[];
}

export type BaseEntityDialogueOption = {
  text: string;
  dismiss?: boolean;
  nextDialogue?: BaseEntityDialogue;
  onSelect?: (interactor: GamePlayerEntity) => void;
}

export type BaseEntityDialogueRoot = {
  avatarImageUri: string;
  title?: string;
  dialogue: BaseEntityDialogue;
}

export type BaseEntityItemDrop = {
  item: BaseItem;
  maxQuantity?: number; // Alternative range vs quantity
  minQuantity?: number; // Alternative range vs quantity
  probability: number; // 0 - 1
  quantity?: number;
}

export type BaseEntityOptions = {
  combatExperienceReward?: number;
  controller?: PathfindingEntityController;
  deathAnimations?: string[];
  deathDespawnDelayMs?: number;
  deathItemDrops?: BaseEntityItemDrop[];
  dialogue?: BaseEntityDialogueRoot;
  facingAngle?: number;
  facingPosition?: Vector3Like;
  idleAnimations?: string[];
  idleAnimationSpeed?: number;
  health?: number;
  moveAnimations?: string[];
  moveAnimationSpeed?: number;
  moveSpeed?: number;
  pushable?: boolean;
} & EntityOptions;

export type WanderOptions = {
  idleMinMs: number;
  idleMaxMs: number;
  moveOptions?: MoveOptions;
  pathfindOptions?: PathfindingOptions;
}

export default class BaseEntity extends Entity implements IInteractable, IDamageable {
  private _combatExperienceReward: number;
  private _deathAnimations: string[];
  private _deathDespawnDelayMs: number;
  private _deathItemDrops: BaseEntityItemDrop[];
  private _dialogueRoot: BaseEntityDialogueRoot | undefined;
  private _dialogueMap: Map<number, BaseEntityDialogue> = new Map();
  private _dying: boolean = false;
  private _health: number;
  private _maxHealth: number;
  private _moveSpeed: number;
  private _nameplateSceneUI: SceneUI;
  private _wanderAccumulatorMs: number = 0;
  
  public constructor(options: BaseEntityOptions) {
    super({
      ...options,
      controller: new PathfindingEntityController(),
      rigidBodyOptions: {
        ...options.rigidBodyOptions,
        type: RigidBodyType.DYNAMIC,
        enabledRotations: { x: false, y: true, z: false },
        rotation: Quaternion.fromEuler(0, options.facingAngle ?? 0, 0),
        additionalMass: !options.pushable ? 1000 : 0,
      }
    });

    this._combatExperienceReward = options.combatExperienceReward ?? 0;
    this._deathAnimations = options.deathAnimations ?? [];
    this._deathDespawnDelayMs = options.deathDespawnDelayMs ?? 0;
    this._deathItemDrops = options.deathItemDrops ?? [];
    this._dialogueRoot = options.dialogue;
    this._health = options.health ?? 0; // 0 is infinite health, will not show health bar
    this._maxHealth = this._health;
    this._moveSpeed = options.moveSpeed ?? 2;

    // Build dialogue map with auto-assigned IDs if dialogue exists
    if (this._dialogueRoot) {
      this.buildDialogueMap();
    }

    this.pathfindingController.idleLoopedAnimations = options.idleAnimations ?? [];
    this.pathfindingController.idleLoopedAnimationsSpeed = options.idleAnimationSpeed ?? undefined;
    this.pathfindingController.moveLoopedAnimations = options.moveAnimations ?? [];
    this.pathfindingController.moveLoopedAnimationsSpeed = options.moveAnimationSpeed ?? undefined;

    if (options.facingPosition) {
      this.pathfindingController.face(options.facingPosition, this._moveSpeed);
    }

    this.setupNameplateUI();
  }

  public get idleAnimations(): string[] { return this.pathfindingController.idleLoopedAnimations; }
  public get idleAnimationsSpeed(): number | undefined { return this.pathfindingController.idleLoopedAnimationsSpeed; }
  public get isInteractable(): boolean { return !!this._dialogueRoot; }
  public get health(): number { return this._health; }
  public get maxHealth(): number { return this._maxHealth; }
  public get moveAnimations(): string[] { return this.pathfindingController.moveLoopedAnimations; }
  public get moveAnimationsSpeed(): number | undefined { return this.pathfindingController.moveLoopedAnimationsSpeed; }
  public get moveSpeed(): number { return this._moveSpeed; }
  public get pathfindingController(): PathfindingEntityController { return this.controller as PathfindingEntityController; }

  public die(): void {
    if (this._dying) return;

    this._dying = true;

    this.startModelOneshotAnimations(this._deathAnimations);
    this.stopMoving();
    this.dropItems();
    setTimeout(() => this.despawn(), this._deathDespawnDelayMs);
  }

  public dropItems(): void {
    if (!this._deathItemDrops || !this.world) return;

    for (const drop of this._deathItemDrops) {
      if (Math.random() > drop.probability) continue;
      
      // Set quantity
      const quantity = drop.quantity ?? Math.floor(Math.random() * (drop.maxQuantity ?? 1) + (drop.minQuantity ?? 1));
      drop.item.setQuantity(quantity);
      
      // Spawn item for pickup
      drop.item.spawnEntityAsDrop(this.world, this.position);
    }
  }

  public faceTowards(target: Vector3Like, faceSpeed: number) {
    this.pathfindingController.face(target, faceSpeed);
  }

  public getDialogueById(id: number): BaseEntityDialogue | undefined {
    return this._dialogueMap.get(id);
  }

  public interact(interactor: GamePlayerEntity): void {
    if (this._dialogueRoot) {
      interactor.setCurrentDialogueEntity(this);
      this.progressDialogue(interactor, 0);
    }
  }

  public jump(height: number) {
    this.pathfindingController.jump(height);
  }

  public pathfindTo(target: Vector3Like, speed: number = this._moveSpeed, options?: PathfindingOptions) {
    this.pathfindingController.pathfind(target, speed, options);
  }

  public progressDialogue(interactor: GamePlayerEntity, nextDialogueId: number): void {
    const nextDialogue = this.getDialogueById(nextDialogueId);
    if (!this._dialogueRoot || !nextDialogue) return;

    interactor.player.ui.sendData({
      type: 'dialogue',
      avatarImageUri: this._dialogueRoot.avatarImageUri,
      name: this.name,
      title: this._dialogueRoot.title,
      text: nextDialogue.text,
      options: nextDialogue.options?.map(({ text, dismiss, nextDialogue }) => ({
        text,
        dismiss,
        nextDialogueId: nextDialogue?._id,
      })),
    });
  }

  public moveTo(target: Vector3Like, speed: number = this._moveSpeed, options?: MoveOptions) {
    this.pathfindingController.move(target, speed, options);
  }

  public override spawn(world: World, position: Vector3Like, rotation?: QuaternionLike) {
    super.spawn(world, position, rotation);
    this._nameplateSceneUI.load(world);
  }

  public stopMoving() {
    this.pathfindingController.stopFace();
    this.pathfindingController.stopMove();
    // need to add stopPathfind()?
  }

  public takeDamage(damage: number, attacker?: Entity): void {
    // Infinite health, doesn't take damage if max health is 0
    if (this._maxHealth === 0) return; 

    this._health -= damage;

    this._nameplateSceneUI.setState({
      damage,
      health: this._health
    });

    if (this._health <= 0) {
      if (this._combatExperienceReward > 0 && attacker instanceof GamePlayerEntity) {
        attacker.adjustSkillExperience(SkillId.Combat, this._combatExperienceReward);
      }

      this.die();
    }
  }

  public wander(targets: Vector3Like[], speed: number = this._moveSpeed, options?: WanderOptions) {
    const randomIndex = Math.floor(Math.random() * targets.length);
    const target = targets[randomIndex];
    this.pathfindTo(target, speed, {
      debug: true,
      maxFall: 5,
      maxJump: 0,
      maxOpenSetIterations: 400,
      waypointTimeoutMs: 500,
      pathfindCompleteCallback: () => {
        setTimeout(() => this.wander(targets, speed, options), 2000);
      }
    });
    console.log('wandering to', target);
  }

  protected setupNameplateUI(): void {
    this._nameplateSceneUI = new SceneUI({
      attachedToEntity: this,
      offset: { x: 0, y: this.height / 2 + 0.25, z: 0 },
      templateId: 'entity-nameplate',
      state: {
        name: this.name,
        health: this.health,
        interactable: this.isInteractable,
        maxHealth: this.maxHealth,
      },
    });
  }

  private buildDialogueMap(): void {
    if (!this._dialogueRoot) return;
    
    this._dialogueMap.clear();
    let currentId = 0;
    
    const assignDialogueIds = (dialogue: BaseEntityDialogue): void => {
      dialogue._id = currentId;
      this._dialogueMap.set(currentId, dialogue);
      currentId++;
      
      if (dialogue.options) {
        for (const option of dialogue.options) {
          if (option.nextDialogue) {
            assignDialogueIds(option.nextDialogue);
          }
        }
      }
    };
    
    assignDialogueIds(this._dialogueRoot.dialogue);
  }
}