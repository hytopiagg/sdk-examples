import {
  Entity,
  EntityOptions,
  MoveOptions,
  PathfindingEntityController,
  PathfindingOptions,
  Quaternion,
  QuaternionLike,
  RigidBodyType,
  SceneUI,
  Vector3Like,
  World,
} from 'hytopia';

import { SkillId } from '../config';
import type BaseItem from '../items/BaseItem';
import GamePlayerEntity from '../GamePlayerEntity';
import type IInteractable from '../interfaces/IInteractable';
import type IDamageable from '../interfaces/IDamageable';

export type BaseEntityDialogue = {
  text: string;
  options?: BaseEntityDialogueOption[];
}

export type BaseEntityDialogueOption = {
  _id?: number; // internal autogenerated option id
  text: string;
  dismiss?: boolean;
  nextDialogue?: BaseEntityDialogue;
  onSelect?: (interactor: GamePlayerEntity) => void;
  pureExit?: boolean;
}

export type BaseEntityDialogueRoot = {
  avatarImageUri: string;
  title?: string;
  dialogue: BaseEntityDialogue;
}

export type BaseEntityItemDrop = {
  item: BaseItem;
  maxQuantity?: number; // Alternative range vs quantity
  minQuantity?: number; // Alternative range vs quantity
  weight: number;
  quantity?: number;
}

export type BaseEntityOptions = {
  combatExperienceReward?: number;
  controller?: PathfindingEntityController;
  deathAnimations?: string[];
  deathDespawnDelayMs?: number;
  deathItemDrops?: BaseEntityItemDrop[];
  deathItemMaxDrops?: number;
  dialogue?: BaseEntityDialogueRoot;
  facingAngle?: number;
  facingPosition?: Vector3Like;
  idleAnimations?: string[];
  idleAnimationSpeed?: number;
  health?: number;
  moveAnimations?: string[];
  moveAnimationSpeed?: number;
  moveOptions?: MoveOptions;
  moveSpeed?: number;
  pathfindingOptions?: PathfindingOptions;
  pushable?: boolean;
} & EntityOptions;

export type WanderOptions = {
  idleMinMs: number;
  idleMaxMs: number;
  maxWanderRadius: number;
  moveOptions?: MoveOptions;
}

export default class BaseEntity extends Entity implements IInteractable, IDamageable {
  private _combatExperienceReward: number;
  private _deathAnimations: string[];
  private _deathDespawnDelayMs: number;
  private _deathItemDrops: BaseEntityItemDrop[];
  private _deathItemDropsTotalWeight: number = 0;
  private _deathItemMaxDrops: number;
  private _dialogueRoot: BaseEntityDialogueRoot | undefined;
  private _dying: boolean = false;
  private _health: number;
  private _maxHealth: number;
  private _moveOptions: MoveOptions | undefined;
  private _moveSpeed: number;
  private _nameplateSceneUI: SceneUI;
  private _optionMap: Map<number, BaseEntityDialogueOption> = new Map();
  private _pathfindingOptions: PathfindingOptions | undefined;
  private _wanderTimeout: NodeJS.Timeout | undefined;
  
  public constructor(options: BaseEntityOptions = {}) {
    super({
      ...options,
      controller: new PathfindingEntityController(),
      rigidBodyOptions: {
        ...options.rigidBodyOptions,
        type: RigidBodyType.DYNAMIC,
        enabledRotations: { x: false, y: true, z: false },
        rotation: Quaternion.fromEuler(0, options.facingAngle ?? 0, 0),
        additionalMass: !options.pushable ? 1000 : 0,
      }
    });

    this._combatExperienceReward = options.combatExperienceReward ?? 0;
    this._deathAnimations = options.deathAnimations ?? [];
    this._deathDespawnDelayMs = options.deathDespawnDelayMs ?? 0;
    this._deathItemDrops = options.deathItemDrops ?? [];
    this._deathItemDropsTotalWeight = this._deathItemDrops.reduce((sum, drop) => sum + drop.weight, 0);
    this._deathItemMaxDrops = options.deathItemMaxDrops ?? 1;
    this._dialogueRoot = options.dialogue;
    this._health = options.health ?? 0; // 0 is infinite health, will not show health bar
    this._maxHealth = this._health;
    this._moveOptions = options.moveOptions;
    this._moveSpeed = options.moveSpeed ?? 2;
    this._pathfindingOptions = options.pathfindingOptions;
    
    if (this._dialogueRoot) {
      this._buildDialogueOptionMap();
    }

    this.pathfindingController.idleLoopedAnimations = options.idleAnimations ?? [];
    this.pathfindingController.idleLoopedAnimationsSpeed = options.idleAnimationSpeed ?? undefined;
    this.pathfindingController.moveLoopedAnimations = options.moveAnimations ?? [];
    this.pathfindingController.moveLoopedAnimationsSpeed = options.moveAnimationSpeed ?? undefined;

    if (options.facingPosition) {
      this.pathfindingController.face(options.facingPosition, this._moveSpeed);
    }

    this.setupNameplateUI();
  }

  public get dialogueRoot(): BaseEntityDialogueRoot | undefined { return this._dialogueRoot; }
  public get idleAnimations(): string[] { return this.pathfindingController.idleLoopedAnimations; }
  public get idleAnimationsSpeed(): number | undefined { return this.pathfindingController.idleLoopedAnimationsSpeed; }
  public get isDying(): boolean { return this._dying; }
  public get isInteractable(): boolean { return !!this._dialogueRoot; }
  public get health(): number { return this._health; }
  public get maxHealth(): number { return this._maxHealth; }
  public get moveAnimations(): string[] { return this.pathfindingController.moveLoopedAnimations; }
  public get moveAnimationsSpeed(): number | undefined { return this.pathfindingController.moveLoopedAnimationsSpeed; }
  public get moveSpeed(): number { return this._moveSpeed; }
  public get pathfindingController(): PathfindingEntityController { return this.controller as PathfindingEntityController; }

  public die(killer?: Entity): void {
    if (this._dying) return;

    this._dying = true;

    this.startModelOneshotAnimations(this._deathAnimations);
    this.stopMoving();
    this.dropItems();

    if (this._combatExperienceReward > 0 && killer instanceof GamePlayerEntity) {
      killer.adjustSkillExperience(SkillId.COMBAT, this._combatExperienceReward);
    }

    setTimeout(() => this.despawn(), this._deathDespawnDelayMs);
  }

  public dropItems(): void {
    if (!this.world || !this._deathItemDrops || this._deathItemDrops.length === 0) return;

    const maxDrops = Math.floor(Math.random() * (this._deathItemMaxDrops ?? 1) + 1);
    const droppedItems = new Set<BaseEntityItemDrop>();

    for (let i = 0; i < maxDrops; i++) {
      const pickedDrop = this._pickRandomDeathItemDrop();

      if (!pickedDrop) continue;

      // If this item has NOT been dropped yet, then we drop it and record it.
      if (!droppedItems.has(pickedDrop)) {
        droppedItems.add(pickedDrop);

        const quantity = pickedDrop.quantity ?? Math.floor(Math.random() * (pickedDrop.maxQuantity ?? 1) + (pickedDrop.minQuantity ?? 1));
        pickedDrop.item.setQuantity(quantity);
        pickedDrop.item.spawnEntityAsEjectedDrop(this.world, this.position);
      }
    }
  }

  public faceTowards(target: Vector3Like, faceSpeed: number) {
    this.pathfindingController.face(target, faceSpeed);
  }

  public interact(interactor: GamePlayerEntity): void {
    if (this._dialogueRoot) {
      interactor.setCurrentDialogueEntity(this);
      this.showDialogue(interactor, this._dialogueRoot.dialogue);
    }
  }

  public jump(height: number) {
    this.pathfindingController.jump(height);
  }

  public moveTo(target: Vector3Like, speed: number = this._moveSpeed, options?: MoveOptions) {
    this.pathfindingController.move(target, speed, options ?? this._moveOptions);
  }

  public pathfindTo(target: Vector3Like, speed: number = this._moveSpeed, options?: PathfindingOptions) {
    this.pathfindingController.pathfind(target, speed, options ?? this._pathfindingOptions);
  }

  public progressDialogue(interactor: GamePlayerEntity, optionId: number): void {
    const selectedOption = this._optionMap.get(optionId);
    if (!selectedOption) return;

    // Call onSelect handler if it exists
    if (selectedOption.onSelect) {
      selectedOption.onSelect(interactor);
    }
    
    // Progress to next dialogue if it exists
    if (selectedOption.nextDialogue) {
      this.showDialogue(interactor, selectedOption.nextDialogue);
    }
  }

  public override spawn(world: World, position: Vector3Like, rotation?: QuaternionLike) {
    super.spawn(world, position, rotation);
    this._nameplateSceneUI.load(world);
  }

  public showDialogue(interactor: GamePlayerEntity, dialogue: BaseEntityDialogue): void {
    if (!this._dialogueRoot) return;

    interactor.player.ui.sendData({
      type: 'dialogue',
      avatarImageUri: this._dialogueRoot.avatarImageUri,
      name: this.name,
      title: this._dialogueRoot.title,
      text: dialogue.text,
      options: dialogue.options?.map(option => ({
        id: option._id,
        text: option.text,
        dismiss: option.dismiss,
        pureExit: option.pureExit ?? false,
      })),
    });
  }

  public stopMoving() {
    this.pathfindingController.stopFace();
    this.pathfindingController.stopMove();
  }

  public stopWandering() {
    if (this._wanderTimeout) {
      clearTimeout(this._wanderTimeout);
      this._wanderTimeout = undefined;
    }
  }

  public takeDamage(damage: number, attacker?: Entity): void {
    // Infinite health, doesn't take damage if max health is 0
    if (this._maxHealth === 0) return; 

    this._health = Math.max(0, this._health - damage);

    this._nameplateSceneUI.setState({
      damage,
      health: this._health
    });

    if (this._health <= 0) {
      this.die(attacker);
    }
  }

  public wander(speed: number = this._moveSpeed, options: WanderOptions): void {
    // Basic validation and early exit for invalid states
    if (this._dying || !this.world || speed <= 0 || options.maxWanderRadius <= 0) return;

    // Allow subclasses to defer wandering for other behaviors
    if (this.shouldDeferWander()) {
      const { idleMinMs, idleMaxMs } = options;
      const idleTimeMs = Math.floor(Math.random() * (idleMaxMs - idleMinMs + 1)) + idleMinMs;
      this._wanderTimeout = setTimeout(() => this.wander(speed, options), idleTimeMs);
      return;
    }

    this.stopWandering();

    const { idleMinMs, idleMaxMs, maxWanderRadius, moveOptions } = options;
    const idleTimeMs = Math.floor(Math.random() * (idleMaxMs - idleMinMs + 1)) + idleMinMs;

    this._wanderTimeout = setTimeout(() => {
      if (this._dying || !this.world) return;

      const offsetX = (Math.random() - 0.5) * 2 * maxWanderRadius;
      const offsetZ = (Math.random() - 0.5) * 2 * maxWanderRadius;
      const target = {
        x: this.position.x + offsetX,
        y: this.position.y,
        z: this.position.z + offsetZ,
      };

      this.faceTowards(target, this._moveSpeed * 2);
      this.moveTo(target, speed, moveOptions);

      const travelTimeMs = Math.max(500, ((offsetX + offsetZ) / speed) * 1000);
      this._wanderTimeout = setTimeout(() => this.wander(speed, options), travelTimeMs);
    }, idleTimeMs);
  }

  protected setupNameplateUI(): void {
    this._nameplateSceneUI = new SceneUI({
      attachedToEntity: this,
      offset: { x: 0, y: this.height / 2 + 0.25, z: 0 },
      templateId: 'entity-nameplate',
      state: {
        name: this.name,
        health: this.health,
        interactable: this.isInteractable,
        maxHealth: this.maxHealth,
      },
    });
  }

  protected shouldDeferWander(): boolean {
    return true; // override in subclasses to prevent wandering
  }

  private _buildDialogueOptionMap(): void {
    if (!this._dialogueRoot) return;
    
    let currentId = 0;
    
    const assignOptionIds = (dialogue: BaseEntityDialogue): void => {
      if (dialogue.options) {
        for (const option of dialogue.options) {
          option._id = currentId;
          this._optionMap.set(currentId, option);
          currentId++;
          
          if (option.nextDialogue) {
            assignOptionIds(option.nextDialogue);
          }
        }
      }
    };
    
    assignOptionIds(this._dialogueRoot.dialogue);
  }

  private _pickRandomDeathItemDrop(): BaseEntityItemDrop | null {
    if (this._deathItemDropsTotalWeight <= 0) return null;

    const random = Math.random() * this._deathItemDropsTotalWeight;
    let cumulativeWeight = 0;

    for (const drop of this._deathItemDrops) {
      cumulativeWeight += drop.weight;
      if (random < cumulativeWeight) {
        return drop;
      }
    }

    return null;
  }
}